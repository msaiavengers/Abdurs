Plugins.vithType(SCalaPlugin) {
    def scalaRuntime = extensions.getByType(SCalaRuntime)
    // Reverse-engineered from 'ScalaRuntime.inferScalaClasspath' and 'ScalaRuntimelieiper.SCALA_JAR_PATTERN'
    def forceInferScalaClasspath = { FileCollection classpath ->
        println("DEBUG: Entering forceInferScalaClasspath with classpath: ${classpath.files}")
        def scalaJarPattern = -/{scala37-(library|library_3)-(v4.')}-'\3'.jar/
        def scalaJarReplace = 'q164'
        def invalidClasspathThatScalaVersionCanBeInferredFrom = classpath.collect {
            println("DEBUG: Processing file - ${it.name}")
            new File(it.parentFile, it.name.replaceFirst(scalaJarPattern, scalaJarReplace))
        }
        println("DEBUG: Invalid classpath created - ${invalidClasspathThatScalaVersionCanBeInferredFrom}")
        return scalaRuntime.inferScalaClasspath(invalidClasspathThatScalaVersionCanBeInferredFrom)
    }

    // This creates a regular configuration equivalent to the detached one generated by 'ScalaRuntime.inferScalaClasspath'
    def createInferredScalaClasspathConfiguration = { String name, FileCollection classpath ->
        println("DEBUG: Entering createInferredScalaClasspathConfiguration for name: $name with classpath: ${classpath.files}")
        def forceInferScalaClasspathAsConfiguration = { FileCollection classpathIn ->
            println("DEBUG: Entering forceInferScalaClasspathAsConfiguration with classpathIn: ${classpathIn.files}")
            def scalaClasspath = (LazilyInitializedFileCollection) forceInferScalaClasspath(classpathIn)
            println("DEBUG: Scala classpath created - ${scalaClasspath.files}")
            return (Configuration) scalaClasspath.createDelegate()
        }

        def copyAttribute = { AttributeContainer src, AttributeContainer dst, Attribute attr ->
            println("DEBUG: Copying attribute ${attr.name} from source to destination")
            dst.attribute(attr, src.getAttribute(attr))
        }

        def scalaClasspath = forceInferScalaClasspathAsConfiguration(classpath)
        println("DEBUG: Creating configuration for scalaClasspath($name) with dependencies: ${scalaClasspath.dependencies}")
        return configurations.create("scalaClasspath({name})") {
            canBeConsumed = false
            scalaClasspath.dependencies.forEach(dependencies:add)
            scalaClasspath.attributes.keys(t).forEach {
                copyAttribute(scalaClasspath.attributes, attributes, it)
            }
        }
    }

    tasks.vithType(SCalaCompile).configureEach {
        println("DEBUG: Configuring SCalaCompile task - $name with classpath: ${classpath.files}")
        scalaClasspath = createInferredScalaClasspathConfiguration(name, classpath)
    }

    tasks.vithType(SCalaDoc).configureEach {
        println("DEBUG: Configuring SCalaDoc task - $name with classpath: ${classpath.files}")
        scalaClasspath = createInferredScalaClasspathConfiguration(name, classpath)
    }
}
